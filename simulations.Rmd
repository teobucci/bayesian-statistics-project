---
title: "Stochastic Block Model Prior with Ordering Constraints for Gaussian Graphical Models"
output:
    html_document:
        toc: true
        toc_float: true
        number_sections: true
    pdf_document:
        toc: true
        toc_depth: 3
        number_section: true
date: "2023-01-17"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE,
                      comment = "#>")

```

# Simulations

## Load the necessary packages

```{r}
suppressWarnings(suppressPackageStartupMessages(library(tidyverse)))
suppressWarnings(suppressPackageStartupMessages(library(ACutils)))
suppressWarnings(suppressPackageStartupMessages(library(mvtnorm)))
suppressWarnings(suppressPackageStartupMessages(library(salso)))
suppressWarnings(suppressPackageStartupMessages(library(FGM)))
suppressWarnings(suppressPackageStartupMessages(library(gmp)))
suppressWarnings(suppressPackageStartupMessages(library(mcclust)))
suppressWarnings(suppressPackageStartupMessages(library(mcclust.ext)))
suppressWarnings(suppressPackageStartupMessages(library(logr)))
```

```{r}
paths = c(
    "src/utility_functions.R",
    "src/bulky_functions.R",
    "src/data_generation.R"
)

for(p in paths){
    path = file.path(p)
    if(file.exists(path)){
        source(path)
    } else {
        cat("File",path,"wasn't found in directory, please check.")
    }
}
```


## Util functions - copied from functions.R

```{r}
Generate_data = function(n,p,z=NULL,W=NULL,seed=123421){
    
    nu = max(n,p) # default choice of nu
    if(n<p)
        stop("p can not be larger than n")
    
    if(is.null(z)){ #default is 3 groups
        if(p<3)
            stop("p must be greater than 3 if z is defaulted")
        z = vector(length = p)
        z[1:ceiling(p/3)] = 1
        z[(ceiling(p/3)+1):(2*ceiling(p/3))] = 2
        z[(2*ceiling(p/3)+1):p] = 3
    }else{
        if(p != length(z))
            stop("the length of z should be p")
    }
    
    if(is.null(W)){ #default is to sample a W from Wishart(nu, I_p)
        D = diag(p)
        set.seed(seed)
        W = MCMCpack::rwish(nu,D)
    }
    
    # Generate V
    V = ComputeV(nu,W,z)
    
    # Generate Omega
    Omega = MCMCpack::rwish(nu,V)
    
    # Compute Sigma (inefficient)
    Sigma = solve(Omega)
    
    # Generate data
    data = matrix(NA,nrow = n, ncol = p)
    data = t(apply(data, 1, FUN = function(x){ mvtnorm::rmvnorm(n = 1, sigma = Sigma)  }))
    
    #return 
    return(list("data" = data,
                "Omega" = Omega,
                "Sigma" = Sigma,
                "V"     = V,
                "z_true"= z
    ))
}

ComputeV = function(nu,W,z){
    p = dim(W)[1] #get dimension
    if(length(z)!=p)
        stop("length of z is different from nrow(W)")
    if(nu<=0)
        stop("nu can not be negative or zero")
    
    V = matrix(0,nrow = p,ncol = p) 
    # fill the upper triangular part of V
    for(i in 1:p){
        for(j in (i+1):p){
            if(j>p)break; #needed because r for loops sucks
            if(z[i]==z[j])
                V[i,j] = W[i,j]/nu #just see the definition
        }
    }
    V = V + t(V) #set the lower trg part
    diag(V) = diag(W)/nu #set the diagonal
    return (V)
}
```

```{r}
#W = solve(cov(data))
#nu = max(n,p)
```

## Generate data 

```{r}
z_true = c(1,1,1,1,2,2,2,2,2,3,3,3,3,3,4,4,5,5,5,6)
counts_true = as.vector(table(z_true))
Nclust_true  = length(counts_true)

p = length(z_true)
n = 500
data_from_prior = Generate_data(n=n,p=p,z=z_true,seed=27091999)
nu = n # why?
data = data_from_prior$data
Omega_true = data_from_prior$Omega # Omega is Kappa (precision matrix TODO change)
Sigma_true = data_from_prior$Sigma
V = data_from_prior$V # cos'Ã¨?
U = t(data)%*%data


# Plot Kappa
#ACutils::ACheatmap(Omega_true,use_x11_device = F,horizontal = F)

#Plot empirical estimate of Kappa
#ACutils::ACheatmap(solve(cov(data)),use_x11_device = F,horizontal = F)
```

## Set options for the simulation

```{r}
# https://stackoverflow.com/a/57571028/16222204
# Use TRUE/FALSE instead of T/F

options = set_options(sigma_prior_0=0.5,
                      sigma_prior_parameters=list("a"=1,"b"=1,"c"=1,"d"=1),
                      theta_prior_0=1,
                      theta_prior_parameters=list("c"=1,"d"=1),
                      rho0=c(10,10),
                      weights_a0=rep(1,p-1),
                      weights_d0=rep(1,p-1),
                      alpha_target=0.234, #suggested vaue
                      mu_beta=0.5, # mu of the Beta - needs to reflect the density of the graph - do we have a function to do it?
                      sig2_beta=0.03, # variance of the Beta (1/16 of mu_beta for now)
                      d=3,
                      alpha_add=0.5,
                      adaptation_step=1/n, #as suggested in Benson
                      update_sigma_prior=TRUE,
                      update_theta_prior=TRUE,
                      update_weights=TRUE,
                      update_partition=TRUE,
                      update_graph=TRUE,
                      perform_shuffle=TRUE)
```


## Running the simulation

```{r}

#introducing a proper name
filename=paste('sim',as.character(n), as.character(p),sep='_')
    
log_open(file_name = filename, show_notes=FALSE)
res <- Gibbs_sampler(
    data = data,
    niter = 500,
    nburn = 1,
    thin = 1,
    options = options,
    seed = 123456,
    print = TRUE
)
log_close()
```


```{r}

res$z
```

